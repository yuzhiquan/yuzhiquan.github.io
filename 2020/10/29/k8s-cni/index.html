<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s">
     <link rel="shortcut icon" href="/img/favicon.ico">
    <title>
        小胖鱼@Think
    </title>
    <meta name="description" content="CloudNative/Kubernetes/Go">
    <meta name="keywords" content="Kubernetes,Docker,Go">
    <link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">
    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Kubernetes CNI 插件编写
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>CNI(the Container Network Interface),用来抽象容器网络接口，更好的拆分网络功能和接入网络方案</p>
<h3 id="CNI调用"><a href="#CNI调用" class="headerlink" title="CNI调用"></a>CNI调用</h3><p>CNI的调用是集中在CRI部分，在kubelet调用CRI时，里面有一组grpc接口，其中在<code>createsandbox</code>时，进行CNI调用</p>
<p>所以更换CRI可能会对CNI调用有影响</p>
<p>CRI对CNI的调用是通过可执行文件调用并传参执行，所以CNI一定是编译成可执行文件后放在指定目录（可配置）下才能正常调用</p>
<h3 id="CNI组成"><a href="#CNI组成" class="headerlink" title="CNI组成"></a>CNI组成</h3><p>CNI分为main plugin和IPAM两部分，main plugin负责网络创建的主要逻辑，IPAM则主要是IP分配相关</p>
<h4 id="main-plugin"><a href="#main-plugin" class="headerlink" title="main plugin"></a>main plugin</h4><p>目前官方提供了很多plugin，具体参考<a href="https://github.com/containernetworking/plugins/tree/master/plugins/main" target="_blank" rel="noopener">plugin</a>,以及一些开源的，如我们使用的<a href="https://github.com/hustcat/sriov-cni" target="_blank" rel="noopener">sriov</a>和经典的<code>flannel</code>、<code>calico</code>等cni插件</p>
<h4 id="IPAM"><a href="#IPAM" class="headerlink" title="IPAM"></a>IPAM</h4><p>官方同样提供了多个IPAM选择，参考<a href="https://github.com/containernetworking/plugins/tree/master/plugins/ipam" target="_blank" rel="noopener">IPAM</a>, ipam的实现比较简单，就是按照传入的参数，分配IP，保证IP分配正确不重合即可，可以使用分布式存储来保存状态，甚至可以使用本地文件保存</p>
<h3 id="sriov实现"><a href="#sriov实现" class="headerlink" title="sriov实现"></a>sriov实现</h3><p>我们以<a href="https://github.com/hustcat/sriov-cni" target="_blank" rel="noopener">sriov</a>和<a href="https://git.sogou-inc.com/odin/odin-ipam" target="_blank" rel="noopener">odin-ipam</a>来分析如何编写cni插件</p>
<h3 id="main实现"><a href="#main实现" class="headerlink" title="main实现"></a>main实现</h3><p>入口函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	skel.PluginMain(cmdAdd, cmdDel, version.Legacy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是我们需要实现cmdAdd,cmdDel两个函数，新版的cni还需要实现cmdGet，不过不经常使用<br>cmdAdd就是在新建容器过程中调用，它的流程逻辑是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdAdd</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.解析CNI配置</span></span><br><span class="line">	n, err := LoadConf(args.StdinData, args.Args)</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取新建容器创建的network namespace</span></span><br><span class="line">	netns, err := ns.GetNS(args.Netns)</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.根据配置分别进行网卡设置</span></span><br><span class="line">    <span class="comment">// 这里跟sriov特性有关，是只使用PF，还是创建VF虚拟化来用</span></span><br><span class="line">	<span class="keyword">if</span> n.Net.PFOnly != <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err = setupVF(n, args.IfName, netns); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err = setupPF(n, args.IfName, netns); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 调用IPAM分配ip，就是调用下面ipam的cmdAdd</span></span><br><span class="line">	result, err := ipam.ExecAdd(n.Net.IPAM.Type, args.StdinData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"IPAM plugin returned err: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> result.IP4 == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"IPAM plugin returned missing IPv4 config"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.把分配的ip配置在设置好的容器内网卡上</span></span><br><span class="line">	err = netns.Do(<span class="function"><span class="keyword">func</span><span class="params">(_ ns.NetNS)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> err := ipam.ConfigureIface(args.IfName, result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		contVeth, err := net.InterfaceByName(args.IfName)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		logrus.Infof(<span class="string">"arping for ip:%+v with ifveth:%+v"</span>, result.IP4.IP.IP, *contVeth)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> arping.GratuitousArpOverIface(result.IP4.IP.IP, *contVeth)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    result.DNS = n.Net.DNS</span><br><span class="line">    <span class="comment">// 5 打印结果，让cri使用</span></span><br><span class="line">	<span class="keyword">return</span> result.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到main 部分主要实现的功能就是配置解析和容器内网卡设置，这里和要实现网络紧密相关。</p>
<p>cmdDel则是在容器被销毁中调用，用来清理网络设置和ip<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdDel</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 1.解析CNI配置</span></span><br><span class="line">	n, err := LoadConf(args.StdinData, args.Args)</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取新建容器创建的network namespace</span></span><br><span class="line">	netns, err := ns.GetNS(args.Netns)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		_, ok := err.(ns.NSPathNotExistErr)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to open netns %q: %v"</span>, netns, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> netns.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据配置分别进行网卡设置释放</span></span><br><span class="line">	<span class="keyword">if</span> n.Net.PFOnly != <span class="literal">true</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err = releaseVF(n, args.IfName, netns); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err = releasePF(n, args.IfName, netns); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 调用IPAM释放ip，就是调用下面ipam的cmdDel</span></span><br><span class="line">	err = ipam.ExecDel(n.Net.IPAM.Type, args.StdinData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到基本逻辑与cmdAdd类似，只是由创建改为释放网络，并调用ipam释放ip</p>
<h3 id="IPAM-编写"><a href="#IPAM-编写" class="headerlink" title="IPAM 编写"></a>IPAM 编写</h3><p>入口函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	skel.PluginMain(cmdAdd, cmdGet, cmdDel, version.All, about)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是我们需要实现cmdAdd,cmdDel,cmdGet三个函数，<br>cmdAdd就是用来生成一个新ip，它的流程逻辑是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdAdd</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 解析cni中ipam部分的配置</span></span><br><span class="line">	ipamConf, _, err := allocator.LoadIPAMConfig(args.StdinData, args.Args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 2. 初始化backend，这里我们使用etcd作为ip状态存储</span></span><br><span class="line">	store, err := etcd.NewEtcdStore(ipamConf.EtcdEndpoints, ipamConf.EtcdPrefix, ipamConf.CAFile, ipamConf.CertFile, ipamConf.KeyFile)</span><br><span class="line"></span><br><span class="line">	store.DoSession()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> store.Close()</span><br><span class="line">	allocs := []*allocator.IPAllocator&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store all requested IPs in a map, so we can easily remove ones we use</span></span><br><span class="line">	<span class="comment">// and error if some remain</span></span><br><span class="line">	requestedIPs := <span class="keyword">map</span>[<span class="keyword">string</span>]net.IP&#123;&#125; <span class="comment">//net.IP cannot be a key</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, ip := <span class="keyword">range</span> ipamConf.IPArgs &#123;</span><br><span class="line">		requestedIPs[ip.String()] = ip</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 下面就是根据各种配置查询并分配新ip，具体逻辑其实不复杂</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r *current.IPConfig</span><br><span class="line">	e := allocator.IPAMEnvArgs&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> args.Args != <span class="string">""</span> &#123;</span><br><span class="line">		err := types.LoadArgs(args.Args, &amp;e)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> re, err := store.CheckPodName(podName(<span class="keyword">string</span>(e.K8S_POD_NAME), <span class="keyword">string</span>(e.K8S_POD_NAMESPACE), ipamConf.IDC, ipamConf.VLANID)); err == <span class="literal">nil</span> &#123;</span><br><span class="line">				r = re</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> idx, rangeset := <span class="keyword">range</span> ipamConf.Ranges &#123;</span><br><span class="line">			allocator := allocator.NewIPAllocator(&amp;rangeset, store, idx)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check to see if there are any custom IPs requested in this range.</span></span><br><span class="line">			<span class="keyword">var</span> requestedIP net.IP</span><br><span class="line">			<span class="keyword">for</span> k, ip := <span class="keyword">range</span> requestedIPs &#123;</span><br><span class="line">				<span class="keyword">if</span> rangeset.Contains(ip) &#123;</span><br><span class="line">					requestedIP = ip</span><br><span class="line">					<span class="built_in">delete</span>(requestedIPs, k)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ipConf, err := allocator.Get(args.ContainerID, requestedIP)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Deallocate all already allocated IPs</span></span><br><span class="line">				<span class="keyword">for</span> _, alloc := <span class="keyword">range</span> allocs &#123;</span><br><span class="line">					_ = alloc.Release(args.ContainerID)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to allocate for range %d: %v"</span>, idx, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			allocs = <span class="built_in">append</span>(allocs, allocator)</span><br><span class="line"></span><br><span class="line">			result.IPs = <span class="built_in">append</span>(result.IPs, ipConf)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := store.ReservePodName(podName(<span class="keyword">string</span>(e.K8S_POD_NAME), <span class="keyword">string</span>(e.K8S_POD_NAMESPACE), ipamConf.IDC, ipamConf.VLANID), ipConf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"[odin-ipam] cmd add reserve podname :%s failed: %+v"</span>, e.K8S_POD_NAME, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> store.CheckPodIP(r.Address.IP.String()) != <span class="literal">nil</span> &#123;</span><br><span class="line">			store.ReleasePodName(podName(<span class="keyword">string</span>(e.K8S_POD_NAME), <span class="keyword">string</span>(e.K8S_POD_NAMESPACE), ipamConf.IDC, ipamConf.VLANID))</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf( <span class="string">"ip %s already taken, may be u need another ip"</span>, r.Address.IP.String())</span><br><span class="line">		&#125;</span><br><span class="line">		result.IPs = <span class="built_in">append</span>(result.IPs, r)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If an IP was requested that wasn't fulfilled, fail</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(requestedIPs) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, alloc := <span class="keyword">range</span> allocs &#123;</span><br><span class="line">			_ = alloc.Release(args.ContainerID)</span><br><span class="line">		&#125;</span><br><span class="line">		errstr := <span class="string">"failed to allocate all requested IPs:"</span></span><br><span class="line">		<span class="keyword">for</span> _, ip := <span class="keyword">range</span> requestedIPs &#123;</span><br><span class="line">			errstr = errstr + <span class="string">" "</span> + ip.String()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(errstr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result.Routes = ipamConf.Routes</span><br><span class="line">	oldResult, err := types020.GetResult(result)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> oldResult.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cmdAdd整体也不复杂，主要就是遍历cidr里所有ip并对比存储里ip状态，看哪些ip可以分配，然后就分配一个出来，相应的cmdDel逻辑就更简单了，就是把指定的ip状态删除，这样就可以在后续继续使用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdDel</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ipamConf, _, err := allocator.LoadIPAMConfig(args.StdinData, args.Args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	store, err := etcd.NewEtcdStore(ipamConf.EtcdEndpoints, ipamConf.EtcdPrefix, ipamConf.CAFile, ipamConf.CertFile, ipamConf.KeyFile)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	store.DoSession()</span><br><span class="line">	<span class="keyword">defer</span> store.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Loop through all ranges, releasing all IPs, even if an error occurs</span></span><br><span class="line">	<span class="keyword">var</span> errors []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> idx, rangeset := <span class="keyword">range</span> ipamConf.Ranges &#123;</span><br><span class="line">		ipAllocator := allocator.NewIPAllocator(&amp;rangeset, store, idx)</span><br><span class="line"></span><br><span class="line">		err := ipAllocator.Release(args.ContainerID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errors = <span class="built_in">append</span>(errors, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> errors != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(strings.Join(errors, <span class="string">";"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">"[odin-ipam]cmd del release ContainerID:%s succ"</span>, args.ContainerID)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: yuzhiquan | Theme By <a class="theme-author" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="xvQv3v6vkbQqL7IBhjet04Ux-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="9AbHntN8K0I3hTo5R3kXGN0D">
<script src="/libs/jquery.min.js"></script>
<script src="/libs/highlight/highlight.pack.js"></script>
<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script src="/js/js.js"></script>
<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
